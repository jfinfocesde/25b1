# Semana 7: Herencia en Programación Orientada a Objetos (Java)

## ¿Qué es la Herencia?

La **herencia** es uno de los pilares fundamentales de la Programación Orientada a Objetos (POO). Permite que una clase (llamada **clase hija** o **subclase**) herede atributos y métodos de otra clase (llamada **clase padre** o **superclase**).

### Características principales:
- **Reutilización de código**: Evita duplicar código común
- **Jerarquía de clases**: Establece relaciones "es-un" entre objetos
- **Extensibilidad**: Permite agregar funcionalidad específica a las subclases
- **Polimorfismo**: Facilita el tratamiento uniforme de objetos relacionados

## Sintaxis en Java

En Java, utilizamos la palabra clave `extends` para establecer herencia:

```java
class ClasePadre {
    // Atributos y métodos de la clase padre
}

class ClaseHija extends ClasePadre {
    // Atributos y métodos adicionales de la clase hija
    // Hereda automáticamente todo lo público y protegido del padre
}
```

## Ejemplo Básico: Vehículos

### Clase Padre (Superclase)

```java
public class Vehiculo {
    protected String marca;
    protected String modelo;
    protected int año;
    protected double velocidad;
    
    // Constructor
    public Vehiculo(String marca, String modelo, int año) {
        this.marca = marca;
        this.modelo = modelo;
        this.año = año;
        this.velocidad = 0.0;
    }
    
    // Métodos comunes a todos los vehículos
    public void acelerar(double incremento) {
        velocidad += incremento;
        System.out.println("Acelerando... Velocidad actual: " + velocidad + " km/h");
    }
    
    public void frenar(double decremento) {
        velocidad = Math.max(0, velocidad - decremento);
        System.out.println("Frenando... Velocidad actual: " + velocidad + " km/h");
    }
    
    public void mostrarInfo() {
        System.out.println("Vehículo: " + marca + " " + modelo + " (" + año + ")");
    }
    
    // Getters
    public String getMarca() { return marca; }
    public String getModelo() { return modelo; }
    public int getAño() { return año; }
    public double getVelocidad() { return velocidad; }
}
```

### Clases Hijas (Subclases)

#### Clase Auto

```java
public class Auto extends Vehiculo {
    private int numeroPuertas;
    private String tipoCombustible;
    
    // Constructor que llama al constructor del padre
    public Auto(String marca, String modelo, int año, int numeroPuertas, String tipoCombustible) {
        super(marca, modelo, año); // Llamada al constructor del padre
        this.numeroPuertas = numeroPuertas;
        this.tipoCombustible = tipoCombustible;
    }
    
    // Método específico de Auto
    public void encenderAireAcondicionado() {
        System.out.println("Aire acondicionado encendido en el " + marca + " " + modelo);
    }
    
    // Sobrescritura (Override) del método mostrarInfo
    @Override
    public void mostrarInfo() {
        super.mostrarInfo(); // Llama al método del padre
        System.out.println("Tipo: Auto");
        System.out.println("Puertas: " + numeroPuertas);
        System.out.println("Combustible: " + tipoCombustible);
    }
    
    // Getters específicos
    public int getNumeroPuertas() { return numeroPuertas; }
    public String getTipoCombustible() { return tipoCombustible; }
}
```

#### Clase Motocicleta

```java
public class Motocicleta extends Vehiculo {
    private int cilindrada;
    private boolean tieneSidecar;
    
    public Motocicleta(String marca, String modelo, int año, int cilindrada, boolean tieneSidecar) {
        super(marca, modelo, año);
        this.cilindrada = cilindrada;
        this.tieneSidecar = tieneSidecar;
    }
    
    // Método específico de Motocicleta
    public void hacerCaballito() {
        if (velocidad > 20) {
            System.out.println("¡Haciendo caballito con la " + marca + " " + modelo + "!");
        } else {
            System.out.println("Necesitas más velocidad para hacer caballito.");
        }
    }
    
    @Override
    public void mostrarInfo() {
        super.mostrarInfo();
        System.out.println("Tipo: Motocicleta");
        System.out.println("Cilindrada: " + cilindrada + "cc");
        System.out.println("Sidecar: " + (tieneSidecar ? "Sí" : "No"));
    }
    
    public int getCilindrada() { return cilindrada; }
    public boolean isTieneSidecar() { return tieneSidecar; }
}
```

## Conceptos Importantes

### 1. La palabra clave `super`

- **`super()`**: Llama al constructor de la clase padre
- **`super.metodo()`**: Llama a un método de la clase padre
- **`super.atributo`**: Accede a un atributo de la clase padre

### 2. Sobrescritura de métodos (`@Override`)

Permite que una subclase proporcione una implementación específica de un método que ya está definido en su superclase.

```java
@Override
public void mostrarInfo() {
    super.mostrarInfo(); // Opcional: llamar al método del padre
    // Agregar funcionalidad específica
    System.out.println("Información adicional específica");
}
```

### 3. Modificadores de acceso en herencia

- **`public`**: Accesible desde cualquier lugar
- **`protected`**: Accesible desde la misma clase, subclases y mismo paquete
- **`private`**: NO heredable, solo accesible desde la misma clase
- **Sin modificador (package-private)**: Accesible desde el mismo paquete

## Ejemplo de Uso Completo

```java
public class EjemploHerencia {
    public static void main(String[] args) {
        // Crear objetos de diferentes tipos
        Auto miAuto = new Auto("Toyota", "Corolla", 2023, 4, "Gasolina");
        Motocicleta miMoto = new Motocicleta("Yamaha", "R1", 2022, 1000, false);
        
        System.out.println("=== INFORMACIÓN DE VEHÍCULOS ===");
        miAuto.mostrarInfo();
        System.out.println();
        miMoto.mostrarInfo();
        
        System.out.println("\n=== PROBANDO FUNCIONALIDADES ===");
        
        // Métodos heredados (disponibles en ambos)
        miAuto.acelerar(50);
        miMoto.acelerar(80);
        
        // Métodos específicos de cada clase
        miAuto.encenderAireAcondicionado();
        miMoto.hacerCaballito();
        
        // Polimorfismo: tratar objetos diferentes de manera uniforme
        System.out.println("\n=== POLIMORFISMO ===");
        Vehiculo[] vehiculos = {miAuto, miMoto};
        
        for (Vehiculo vehiculo : vehiculos) {
            vehiculo.mostrarInfo(); // Llama al método sobrescrito correspondiente
            vehiculo.acelerar(20);
            System.out.println();
        }
    }
}
```

## Ventajas de la Herencia

1. **Reutilización de código**: Evita duplicación
2. **Mantenimiento**: Cambios en la clase padre se propagan automáticamente
3. **Organización**: Crea jerarquías lógicas y comprensibles
4. **Extensibilidad**: Fácil agregar nuevas funcionalidades
5. **Polimorfismo**: Permite tratar objetos relacionados de manera uniforme

## Consideraciones Importantes

- Java solo permite **herencia simple** (una clase solo puede extender una clase)
- Todas las clases en Java heredan implícitamente de `Object`
- Los constructores NO se heredan, pero se pueden llamar con `super()`
- Los métodos `private` NO se heredan
- Los métodos `static` se heredan pero no se pueden sobrescribir

!!! tip "Buena Práctica"
    Usa herencia cuando existe una relación "es-un" clara. Por ejemplo: "Un Auto ES-UN Vehículo", "Una Motocicleta ES-UN Vehículo".

!!! warning "Cuidado"
    No abuses de la herencia. A veces la composición ("tiene-un") es más apropiada que la herencia ("es-un").

## Ejemplo Exhaustivo: Sistema de Empleados

A continuación se presenta un ejemplo completamente funcional de herencia con lógica de negocio detallada:

### Clase Padre: Empleado

```java
public class Empleado {
    // Atributos protegidos para que las subclases puedan acceder
    protected String nombre;
    protected String apellido;
    protected String cedula;
    protected double salarioBase;
    protected int añosExperiencia;
    protected String departamento;
    
    // Constructor
    public Empleado(String nombre, String apellido, String cedula, 
                   double salarioBase, int añosExperiencia, String departamento) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.cedula = cedula;
        this.salarioBase = salarioBase;
        this.añosExperiencia = añosExperiencia;
        this.departamento = departamento;
    }
    
    // Métodos getter
    public String getNombre() {
        return nombre;
    }
    
    public String getApellido() {
        return apellido;
    }
    
    public String getCedula() {
        return cedula;
    }
    
    public double getSalarioBase() {
        return salarioBase;
    }
    
    public int getAñosExperiencia() {
        return añosExperiencia;
    }
    
    public String getDepartamento() {
        return departamento;
    }
    
    // Métodos setter
    public void setNombre(String nombre) {
        this.nombre = nombre;
    }
    
    public void setApellido(String apellido) {
        this.apellido = apellido;
    }
    
    public void setCedula(String cedula) {
        this.cedula = cedula;
    }
    
    public void setSalarioBase(double salarioBase) {
        if (salarioBase > 0) {
            this.salarioBase = salarioBase;
        }
    }
    
    public void setAñosExperiencia(int añosExperiencia) {
        if (añosExperiencia >= 0) {
            this.añosExperiencia = añosExperiencia;
        }
    }
    
    public void setDepartamento(String departamento) {
        this.departamento = departamento;
    }
    
    // Métodos de lógica de negocio
    public double calcularSalarioTotal() {
        // Bono por experiencia: 2% por cada año
        double bonoExperiencia = salarioBase * (añosExperiencia * 0.02);
        return salarioBase + bonoExperiencia;
    }
    
    public double calcularBonoAnual() {
        // Bono anual básico equivalente a un mes de salario
        return calcularSalarioTotal();
    }
    
    public String obtenerNombreCompleto() {
        return nombre + " " + apellido;
    }
    
    public void mostrarInformacion() {
        System.out.println("=== INFORMACIÓN DEL EMPLEADO ===");
        System.out.println("Nombre: " + obtenerNombreCompleto());
        System.out.println("Cédula: " + cedula);
        System.out.println("Departamento: " + departamento);
        System.out.println("Años de experiencia: " + añosExperiencia);
        System.out.println("Salario base: $" + String.format("%.2f", salarioBase));
        System.out.println("Salario total: $" + String.format("%.2f", calcularSalarioTotal()));
        System.out.println("Bono anual: $" + String.format("%.2f", calcularBonoAnual()));
    }
    
    public boolean esElegibleParaPromocion() {
        return añosExperiencia >= 3;
    }
}
```

### Clase Hija: Desarrollador

```java
public class Desarrollador extends Empleado {
    // Atributos específicos del desarrollador
    private String lenguajePrincipal;
    private int proyectosCompletados;
    private String nivelSenioridad; // Junior, Mid, Senior
    private boolean certificacionesActivas;
    
    // Constructor
    public Desarrollador(String nombre, String apellido, String cedula,
                        double salarioBase, int añosExperiencia, String departamento,
                        String lenguajePrincipal, int proyectosCompletados, 
                        String nivelSenioridad, boolean certificacionesActivas) {
        // Llamar al constructor de la clase padre
        super(nombre, apellido, cedula, salarioBase, añosExperiencia, departamento);
        this.lenguajePrincipal = lenguajePrincipal;
        this.proyectosCompletados = proyectosCompletados;
        this.nivelSenioridad = nivelSenioridad;
        this.certificacionesActivas = certificacionesActivas;
    }
    
    // Getters específicos
    public String getLenguajePrincipal() {
        return lenguajePrincipal;
    }
    
    public int getProyectosCompletados() {
        return proyectosCompletados;
    }
    
    public String getNivelSenioridad() {
        return nivelSenioridad;
    }
    
    public boolean isCertificacionesActivas() {
        return certificacionesActivas;
    }
    
    // Setters específicos
    public void setLenguajePrincipal(String lenguajePrincipal) {
        this.lenguajePrincipal = lenguajePrincipal;
    }
    
    public void setProyectosCompletados(int proyectosCompletados) {
        if (proyectosCompletados >= 0) {
            this.proyectosCompletados = proyectosCompletados;
        }
    }
    
    public void setNivelSenioridad(String nivelSenioridad) {
        this.nivelSenioridad = nivelSenioridad;
    }
    
    public void setCertificacionesActivas(boolean certificacionesActivas) {
        this.certificacionesActivas = certificacionesActivas;
    }
    
    // Sobrescritura del método calcularSalarioTotal con lógica específica
    @Override
    public double calcularSalarioTotal() {
        // Obtener el salario base con bono de experiencia
        double salarioConExperiencia = super.calcularSalarioTotal();
        
        // Bono por nivel de senioridad
        double bonoSenioridad = 0;
        switch (nivelSenioridad.toLowerCase()) {
            case "junior":
                bonoSenioridad = salarioBase * 0.05; // 5%
                break;
            case "mid":
                bonoSenioridad = salarioBase * 0.15; // 15%
                break;
            case "senior":
                bonoSenioridad = salarioBase * 0.30; // 30%
                break;
        }
        
        // Bono por proyectos completados (1% por proyecto)
        double bonoProyectos = salarioBase * (proyectosCompletados * 0.01);
        
        // Bono por certificaciones activas
        double bonoCertificaciones = certificacionesActivas ? salarioBase * 0.10 : 0;
        
        return salarioConExperiencia + bonoSenioridad + bonoProyectos + bonoCertificaciones;
    }
    
    // Sobrescritura del método calcularBonoAnual
    @Override
    public double calcularBonoAnual() {
        // Bono anual mejorado para desarrolladores
        double bonoBase = super.calcularBonoAnual();
        
        // Bono adicional por rendimiento técnico
        if (proyectosCompletados >= 10) {
            bonoBase += salarioBase * 0.5; // 50% adicional
        } else if (proyectosCompletados >= 5) {
            bonoBase += salarioBase * 0.25; // 25% adicional
        }
        
        return bonoBase;
    }
    
    // Métodos específicos del desarrollador
    public void completarProyecto() {
        proyectosCompletados++;
        System.out.println(obtenerNombreCompleto() + " ha completado un nuevo proyecto.");
        System.out.println("Total de proyectos: " + proyectosCompletados);
    }
    
    public void actualizarCertificaciones(boolean estado) {
        certificacionesActivas = estado;
        String mensaje = estado ? "activadas" : "desactivadas";
        System.out.println("Certificaciones " + mensaje + " para " + obtenerNombreCompleto());
    }
    
    public double calcularProductividad() {
        // Productividad basada en proyectos por año de experiencia
        if (añosExperiencia == 0) return 0;
        return (double) proyectosCompletados / añosExperiencia;
    }
    
    // Sobrescritura del método mostrarInformacion
    @Override
    public void mostrarInformacion() {
        super.mostrarInformacion(); // Mostrar información básica
        System.out.println("=== INFORMACIÓN ESPECÍFICA DEL DESARROLLADOR ===");
        System.out.println("Lenguaje principal: " + lenguajePrincipal);
        System.out.println("Nivel de senioridad: " + nivelSenioridad);
        System.out.println("Proyectos completados: " + proyectosCompletados);
        System.out.println("Certificaciones activas: " + (certificacionesActivas ? "Sí" : "No"));
        System.out.println("Productividad: " + String.format("%.2f", calcularProductividad()) + " proyectos/año");
    }
    
    @Override
    public boolean esElegibleParaPromocion() {
        // Criterios específicos para desarrolladores
        return super.esElegibleParaPromocion() && 
               proyectosCompletados >= 5 && 
               certificacionesActivas;
    }
}
```

### Clase Hija: Gerente

```java
public class Gerente extends Empleado {
    // Atributos específicos del gerente
    private int equipoACargoTamaño;
    private double presupuestoAnual;
    private int metasCumplidas;
    private int metasTotales;
    private String tipoGerencia; // Operacional, Estratégica, Técnica
    
    // Constructor
    public Gerente(String nombre, String apellido, String cedula,
                  double salarioBase, int añosExperiencia, String departamento,
                  int equipoACargoTamaño, double presupuestoAnual, 
                  int metasCumplidas, int metasTotales, String tipoGerencia) {
        super(nombre, apellido, cedula, salarioBase, añosExperiencia, departamento);
        this.equipoACargoTamaño = equipoACargoTamaño;
        this.presupuestoAnual = presupuestoAnual;
        this.metasCumplidas = metasCumplidas;
        this.metasTotales = metasTotales;
        this.tipoGerencia = tipoGerencia;
    }
    
    // Getters específicos
    public int getEquipoACargoTamaño() {
        return equipoACargoTamaño;
    }
    
    public double getPresupuestoAnual() {
        return presupuestoAnual;
    }
    
    public int getMetasCumplidas() {
        return metasCumplidas;
    }
    
    public int getMetasTotales() {
        return metasTotales;
    }
    
    public String getTipoGerencia() {
        return tipoGerencia;
    }
    
    // Setters específicos
    public void setEquipoACargoTamaño(int equipoACargoTamaño) {
        if (equipoACargoTamaño >= 0) {
            this.equipoACargoTamaño = equipoACargoTamaño;
        }
    }
    
    public void setPresupuestoAnual(double presupuestoAnual) {
        if (presupuestoAnual >= 0) {
            this.presupuestoAnual = presupuestoAnual;
        }
    }
    
    public void setMetasCumplidas(int metasCumplidas) {
        if (metasCumplidas >= 0 && metasCumplidas <= metasTotales) {
            this.metasCumplidas = metasCumplidas;
        }
    }
    
    public void setMetasTotales(int metasTotales) {
        if (metasTotales >= 0) {
            this.metasTotales = metasTotales;
            // Ajustar metas cumplidas si es necesario
            if (metasCumplidas > metasTotales) {
                metasCumplidas = metasTotales;
            }
        }
    }
    
    public void setTipoGerencia(String tipoGerencia) {
        this.tipoGerencia = tipoGerencia;
    }
    
    // Sobrescritura del método calcularSalarioTotal
    @Override
    public double calcularSalarioTotal() {
        double salarioConExperiencia = super.calcularSalarioTotal();
        
        // Bono por tamaño del equipo (2% por cada persona)
        double bonoEquipo = salarioBase * (equipoACargoTamaño * 0.02);
        
        // Bono por tipo de gerencia
        double bonoTipo = 0;
        switch (tipoGerencia.toLowerCase()) {
            case "operacional":
                bonoTipo = salarioBase * 0.20; // 20%
                break;
            case "estratégica":
                bonoTipo = salarioBase * 0.35; // 35%
                break;
            case "técnica":
                bonoTipo = salarioBase * 0.25; // 25%
                break;
        }
        
        // Bono por cumplimiento de metas
        double porcentajeMetas = metasTotales > 0 ? (double) metasCumplidas / metasTotales : 0;
        double bonoMetas = salarioBase * (porcentajeMetas * 0.30); // Hasta 30%
        
        return salarioConExperiencia + bonoEquipo + bonoTipo + bonoMetas;
    }
    
    @Override
    public double calcularBonoAnual() {
        double bonoBase = super.calcularBonoAnual();
        
        // Bono adicional por gestión exitosa
        double porcentajeMetas = metasTotales > 0 ? (double) metasCumplidas / metasTotales : 0;
        if (porcentajeMetas >= 0.9) { // 90% o más de metas cumplidas
            bonoBase += salarioBase * 1.0; // 100% adicional
        } else if (porcentajeMetas >= 0.7) { // 70% o más
            bonoBase += salarioBase * 0.5; // 50% adicional
        }
        
        return bonoBase;
    }
    
    // Métodos específicos del gerente
    public void cumplirMeta() {
        if (metasCumplidas < metasTotales) {
            metasCumplidas++;
            System.out.println(obtenerNombreCompleto() + " ha cumplido una nueva meta.");
            System.out.println("Progreso: " + metasCumplidas + "/" + metasTotales + " metas");
        } else {
            System.out.println("Todas las metas ya han sido cumplidas.");
        }
    }
    
    public void agregarMiembroEquipo() {
        equipoACargoTamaño++;
        System.out.println("Nuevo miembro agregado al equipo de " + obtenerNombreCompleto());
        System.out.println("Tamaño actual del equipo: " + equipoACargoTamaño + " personas");
    }
    
    public double calcularPorcentajeMetas() {
        return metasTotales > 0 ? (double) metasCumplidas / metasTotales * 100 : 0;
    }
    
    public double calcularPresupuestoPorPersona() {
        return equipoACargoTamaño > 0 ? presupuestoAnual / equipoACargoTamaño : 0;
    }
    
    @Override
    public void mostrarInformacion() {
        super.mostrarInformacion();
        System.out.println("=== INFORMACIÓN ESPECÍFICA DEL GERENTE ===");
        System.out.println("Tipo de gerencia: " + tipoGerencia);
        System.out.println("Tamaño del equipo: " + equipoACargoTamaño + " personas");
        System.out.println("Presupuesto anual: $" + String.format("%.2f", presupuestoAnual));
        System.out.println("Metas cumplidas: " + metasCumplidas + "/" + metasTotales);
        System.out.println("Porcentaje de cumplimiento: " + String.format("%.1f", calcularPorcentajeMetas()) + "%");
        System.out.println("Presupuesto por persona: $" + String.format("%.2f", calcularPresupuestoPorPersona()));
    }
    
    @Override
    public boolean esElegibleParaPromocion() {
        // Criterios específicos para gerentes
        return super.esElegibleParaPromocion() && 
               calcularPorcentajeMetas() >= 80.0 && 
               equipoACargoTamaño >= 5;
    }
}
```

### Clase de Demostración Completa

```java
public class SistemaEmpleados {
    public static void main(String[] args) {
        System.out.println("=== SISTEMA DE GESTIÓN DE EMPLEADOS ===");
        System.out.println();
        
        // Crear empleados de diferentes tipos
        Empleado empleadoGeneral = new Empleado(
            "Ana", "García", "12345678", 3000000, 2, "Recursos Humanos"
        );
        
        Desarrollador desarrollador = new Desarrollador(
            "Carlos", "Rodríguez", "87654321", 4500000, 4, "Tecnología",
            "Java", 8, "Mid", true
        );
        
        Gerente gerente = new Gerente(
            "María", "López", "11223344", 8000000, 7, "Operaciones",
            12, 500000000, 7, 10, "Estratégica"
        );
        
        // Mostrar información inicial
        System.out.println("\n=== INFORMACIÓN INICIAL DE EMPLEADOS ===");
        empleadoGeneral.mostrarInformacion();
        System.out.println();
        
        desarrollador.mostrarInformacion();
        System.out.println();
        
        gerente.mostrarInformacion();
        System.out.println();
        
        // Demostrar funcionalidades específicas
        System.out.println("=== DEMOSTRANDO FUNCIONALIDADES ESPECÍFICAS ===");
        
        // Desarrollador completa proyectos
        desarrollador.completarProyecto();
        desarrollador.completarProyecto();
        System.out.println("Nueva productividad: " + 
                          String.format("%.2f", desarrollador.calcularProductividad()) + 
                          " proyectos/año\n");
        
        // Gerente cumple metas
        gerente.cumplirMeta();
        gerente.cumplirMeta();
        gerente.agregarMiembroEquipo();
        System.out.println();
        
        // Verificar elegibilidad para promoción
        System.out.println("=== ELEGIBILIDAD PARA PROMOCIÓN ===");
        System.out.println(empleadoGeneral.obtenerNombreCompleto() + 
                          " elegible: " + empleadoGeneral.esElegibleParaPromocion());
        System.out.println(desarrollador.obtenerNombreCompleto() + 
                          " elegible: " + desarrollador.esElegibleParaPromocion());
        System.out.println(gerente.obtenerNombreCompleto() + 
                          " elegible: " + gerente.esElegibleParaPromocion());
        System.out.println();
        
        // Demostrar polimorfismo
        System.out.println("=== DEMOSTRACIÓN DE POLIMORFISMO ===");
        Empleado[] empleados = {empleadoGeneral, desarrollador, gerente};
        
        double totalSalarios = 0;
        double totalBonos = 0;
        
        for (Empleado emp : empleados) {
            System.out.println("Procesando: " + emp.obtenerNombreCompleto());
            System.out.println("Salario total: $" + String.format("%.2f", emp.calcularSalarioTotal()));
            System.out.println("Bono anual: $" + String.format("%.2f", emp.calcularBonoAnual()));
            
            totalSalarios += emp.calcularSalarioTotal();
            totalBonos += emp.calcularBonoAnual();
            System.out.println();
        }
        
        System.out.println("=== RESUMEN FINANCIERO ===");
        System.out.println("Total salarios mensuales: $" + String.format("%.2f", totalSalarios));
        System.out.println("Total bonos anuales: $" + String.format("%.2f", totalBonos));
        System.out.println("Costo anual total: $" + String.format("%.2f", (totalSalarios * 12) + totalBonos));
        
        // Demostrar uso de setters
        System.out.println("\n=== ACTUALIZANDO INFORMACIÓN ===");
        desarrollador.setSalarioBase(5000000);
        desarrollador.setNivelSenioridad("Senior");
        System.out.println("Nuevo salario del desarrollador: $" + 
                          String.format("%.2f", desarrollador.calcularSalarioTotal()));
        
        gerente.setPresupuestoAnual(600000000);
        System.out.println("Nuevo presupuesto por persona: $" + 
                          String.format("%.2f", gerente.calcularPresupuestoPorPersona()));
    }
}
```

### Características del Ejemplo

**✅ Cumple todos los requisitos:**

- **Herencia completa**: `Desarrollador` y `Gerente` extienden `Empleado`
- **Solo constructores**: No hay métodos abstractos
- **Getters y setters**: Todos los atributos tienen acceso controlado
- **Métodos concretos**: Toda la funcionalidad está implementada
- **Lógica de negocio detallada**: Cálculos de salarios, bonos, productividad
- **Simplicidad**: Código claro y fácil de entender

**🎯 Funcionalidades implementadas:**

 - Cálculo de salarios con diferentes criterios por tipo de empleado
 - Sistema de bonificaciones específico para cada rol
 - Validaciones en setters para mantener integridad de datos
 - Polimorfismo para tratar diferentes tipos de empleados uniformemente
 - Métricas de rendimiento específicas (productividad, cumplimiento de metas)
 - Sistema de elegibilidad para promociones con criterios diferenciados

