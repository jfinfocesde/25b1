#  Semana 4 - Constructores, encapsulación y métodos de acceso en Java  

---

## 1. Introducción  
Una clase Java que **almacena información sensible** (saldo bancario, notas de un alumno, etc.) **debe impedir que valores inválidos lleguen a sus atributos**.  
Para ello se combinan:

*   **Constructores**: crean objetos en un estado **válido desde el nacimiento**.  
*   **Encapsulamiento**: ocultar los atributos (`private`) y exponer solo **interfaces controladas**.  
*   **Métodos de acceso** (`get`/`set`): **puertas de entrada y salida** que validan y transforman la información.

---

## 2. Constructores en profundidad  
Un constructor **no devuelve nada**, ni siquiera `void`, y **lleva el mismo nombre que la clase**.

### 2.1 Constructor implícito  
Si no escribes ninguno, Java añade el **constructor por defecto** sin parámetros:

```java
public class Producto { }   // Constructor implícito: new Producto()
```

### 2.2 Constructor sin argumentos (explicit)  
Cuando **necesitas inicializar valores por defecto**:

```java
public class Producto {
    private String nombre;
    private double precio;

    public Producto() {
        this.nombre = "Sin nombre";
        this.precio  = 0.0;
    }
}
```

### 2.3 Constructor con parámetros  
Permite **inicializar con valores concretos** y **validar inmediatamente**:

```java
public Producto(String nombre, double precio) {
    setNombre(nombre);   // reutilizo la validación del setter
    setPrecio(precio);
}
```

### 2.5 Constructores por defecto con Builder (opcional avanzado)  
Para **muchos parámetros opcionales** se usa el patrón *Builder*:

```java
public class Producto {
    private final String nombre;
    private final double precio;
    private final int stock;

    private Producto(Builder b) {
        this.nombre = b.nombre;
        this.precio = b.precio;
        this.stock  = b.stock;
    }

    public static class Builder {
        private String nombre;
        private double precio;
        private int stock;

        public Builder nombre(String val) { nombre = val; return this; }
        public Builder precio(double val) { precio = val; return this; }
        public Builder stock(int val)   { stock = val; return this; }
        public Producto build()         { return new Producto(this); }
    }
}

// Uso
Producto p = new Producto.Builder()
              .nombre("Mouse")
              .precio(29.99)
              .stock(100)
              .build();
```

---

## 3. Encapsulamiento de atributos  
Regla de oro: **todos los atributos de estado deben ser `private`**.  
De esta forma solo la propia clase puede modificarlos directamente.

```java
public class CuentaBancaria {
    private String iban;
    private double saldo;
    private String titular;
}
```

---

## 4. Métodos de acceso (getters y setters)  

### 4.1 Getter  
Devuelve una **copia o vista inmutable** del dato.

```java
public String getIban() {
    return iban;
}

public double getSaldo() {
    return saldo;   // primitivo → copia automática
}
```

> ⚠️ Si devolvieras objetos mutables (ej. `Date`, `List`) devuelve una copia defensiva.

### 4.2 Setter  
Valida y asigna. Es la **única vía oficial** para cambiar el valor.

```java
public void setSaldo(double saldo) {
    if (saldo < 0) {
        throw new IllegalArgumentException("El saldo no puede ser negativo");
    }
    this.saldo = saldo;
}
```

### 4.3 Inmutabilad parcial (solo getter)  
Cuando un atributo **no debe cambiar después de la construcción**, **no incluyas setter**:

```java
public class Dni {
    private final String numero;

    public Dni(String numero) {
        if (!numero.matches("\\d{8}[A-Z]")) {
            throw new IllegalArgumentException("Formato incorrecto");
        }
        this.numero = numero;
    }

    public String getNumero() {   // No existe setNumero
        return numero;
    }
}
```

---

## 5. Ejemplo completo: clase `Alumno`

```java
package modelo;

public class Alumno {
    // 1. Atributos encapsulados
    private String dni;
    private String nombre;
    private double notaMedia;

    // 2. Constructores
    public Alumno() {
        this("00000000X", "Sin nombre", 0.0);
    }

    public Alumno(String dni, String nombre, double notaMedia) {
        setDni(dni);
        setNombre(nombre);
        setNotaMedia(notaMedia);
    }

    public Alumno(Alumno otro) {
        this.dni = otro.dni;
        this.nombre = otro.nombre;
        this.notaMedia = otro.notaMedia;
    }

    // 3. Getters
    public String getDni() {
        return dni;
    }

    public String getNombre() {
        return nombre;
    }

    public double getNotaMedia() {
        return notaMedia;
    }

    // 4. Setters con validación
    public void setDni(String dni) {
        if (dni == null || !dni.matches("\\d{8}[A-Z]")) {
            throw new IllegalArgumentException("DNI inválido");
        }
        this.dni = dni;
    }

    public void setNombre(String nombre) {
        if (nombre == null || nombre.isBlank()) {
            throw new IllegalArgumentException("El nombre no puede estar vacío");
        }
        this.nombre = nombre.trim();
    }

    public void setNotaMedia(double notaMedia) {
        if (notaMedia < 0 || notaMedia > 10) {
            throw new IllegalArgumentException("Nota fuera de rango [0-10]");
        }
        this.notaMedia = notaMedia;
    }

    // 5. Otros métodos de negocio
    public boolean estaAprobado() {
        return notaMedia >= 5;
    }

    @Override
    public String toString() {
        return String.format("Alumno[%s, %s, %.2f]", dni, nombre, notaMedia);
    }
}
```

---

## 6. Buenas prácticas resumidas  

| Recomendación | Motivo |
|---------------|--------|
| Declara los atributos `private` | Evita modificaciones externas no controladas |
| Inicializa en constructores | El objeto **nace válido** |
| Valida en setters y constructores | **Un solo punto de entrada** para reglas de negocio |
| Usa `final` cuando el valor no cambia | Aumenta seguridad y claridad |
| No generes setters de atributos calculados | Ej. `total = precio * cantidad` → calcúlalo en `getTotal()` |

---



## Actividad Práctica: Del mundo real a objetos Java  

---

## Objetivo de la actividad  
Convertir **tres ideas cotidianas** de tu entorno inmediato (casa, colegio, trabajo, parque, redes sociales, transporte, etc.) en **tres clases Java totalmente encapsuladas** que cumplan todos los requisitos solicitados.

---

## Instrucciones paso a paso  

### 1. Fase de exploración (individual o parejas)  
Recorre tu entorno físico o digital y **elige tres “cosas”** que te rodeen y que posean al menos **seis características medibles o distinguibles**.  
Ejemplos válidos:  

*   Un **café de especialidad** (origen, temperatura, tamaño, precio, intensidad, fechaTostado).  
*   Un **ticket de transporte urbano** (línea, origen, destino, precio, fecha, hora salida).  
*   Un **perfil de red social** (alias, númeroSeguidores, númeroSiguiendo, fotoPerfil, biografía, fechaRegistro).  

!!! tip  
    Intenta que los tres dominios sean **diferentes entre sí** para practicar más conceptos.

---

### 2. Diseño UML rápido  
Antes de tocar código, dibuja en una libreta o en [app.diagrams.net](https://app.diagrams.net) un diagrama de clases muy sencillo que contenga:

*   **Nombre de la clase** centrado.  
*   Sección de **atributos** (visibilidad `–` + tipo + nombre).  
*   Sección de **constructores** y **métodos** (visibilidad `+`).  

Ejemplo parcial para la clase `CafeEspecialidad`:

```
--------------------------
|    - origen: String    |
|    - temp: double      |
|    - tamanio: int      |
|    - precio: BigDecimal|
|    - intensidad: int   |
|    - fechaTostado: LocalDate |
--------------------------
| + CafeEspecialidad()          |
| + CafeEspecialidad(...)       |
| + get...() / set...()         |
| + toString()                  |
--------------------------
```

---

### 3. Implementación en Java  
Crea un proyecto Maven o Gradle llamado **EntornoPOO** y dentro el paquete `modelo`.  
Cada clase debe cumplir **todas y cada una** de las siguientes especificaciones:

| Requisito | Detalle |
|-----------|---------|
| **Atributos** | Mínimo **6 atributos de tipos variados** (al menos: `String`, primitivo numérico, `boolean`, tipo fecha o decimal, un objeto propio o `List`). |
| **Encapsulamiento** | Todos los atributos **private**. |
| **Constructor vacío** | Constructor sin parámetros que inicialice valores por defecto razonables. |
| **Constructor por defecto** | *Sinónimo* del vacío; si ya existe, déjalo. Si tu IDE genera uno con valores por defecto, regístralo con comentario `// Constructor por defecto`. |
| **Constructor con parámetros** | Constructor que reciba **los 6 atributos** y los asigne usando los **setters** para reutilizar validaciones. |
| **Getters y Setters** | Un par por atributo. Los **setters deben validar** (ej. no negativos, rangos, no nulos). |
| **toString()** | Override que devuelva una cadena legible con **todos los atributos**. |

---

### 4. Validaciones mínimas por setter (ejemplos)  
| Atributo | Regla de ejemplo |
|----------|------------------|
| `precio` | Mayor que 0, menor que 10 000. |
| `fechaTostado` | No futura, no anterior a 2010. |
| `intensidad` | Solo entre 1 y 10. |

---

### 5. Entregables  

1. **Repositorio Git** con:  
    *   Carpetas `src/main/java/modelo` y `src/test/java`.  
    *   Las **tres clases**.  
    *   Una clase `Main` con un `public static void main(String[] args)` donde instancies al menos **dos objetos por clase**, uno con cada constructor, y los imprimas con `toString()`.  
