#  Semana 11 - Interfaces en Java

## üìö ¬øQu√© es una Interfaz?

Una **interfaz** en Java es un contrato que define qu√© m√©todos debe implementar una clase, pero no especifica c√≥mo implementarlos. Es como un "acuerdo" o "promesa" que una clase hace sobre qu√© comportamientos va a proporcionar.

### üîç Caracter√≠sticas Principales

- **Contrato de comportamiento**: Define QU√â debe hacer una clase, no C√ìMO
- **Abstracci√≥n pura**: Todos los m√©todos son abstractos por defecto (hasta Java 8)
- **Implementaci√≥n m√∫ltiple**: Una clase puede implementar varias interfaces
- **Sin estado**: No pueden tener variables de instancia (solo constantes)
- **Herencia m√∫ltiple de comportamiento**: Permite simular herencia m√∫ltiple

### üåü Analog√≠a del Mundo Real

Imagina una **licencia de conducir**:
- La licencia es como una interfaz que dice "esta persona puede conducir"
- No importa si conduces un carro, moto o cami√≥n (diferentes implementaciones)
- Todos los conductores deben saber acelerar, frenar y girar (m√©todos obligatorios)
- Cada veh√≠culo implementa estos comportamientos de manera diferente

```java
// La "licencia" ser√≠a nuestra interfaz
interface Conductor {
    void acelerar();
    void frenar();
    void girar(String direccion);
}
```

---

## üõ†Ô∏è Declaraci√≥n de una Interfaz

### Sintaxis B√°sica

```java
[modificador] interface NombreInterfaz {
    // Constantes (impl√≠citamente public, static, final)
    tipo CONSTANTE = valor;
    
    // M√©todos abstractos (impl√≠citamente public y abstract)
    tipoRetorno nombreMetodo(parametros);
}
```

### üìù Ejemplo B√°sico

```java
public interface Vehiculo {
    // Constante - velocidad m√°xima permitida
    int VELOCIDAD_MAXIMA = 120;
    
    // M√©todos abstractos que deben implementar las clases
    void encender();
    void apagar();
    void acelerar(int velocidad);
    void frenar();
    String obtenerTipo();
}
```

### üé® Ejemplo con M√∫ltiples M√©todos

```java
public interface Reproductor {
    // Constantes
    int VOLUMEN_MAXIMO = 100;
    int VOLUMEN_MINIMO = 0;
    
    // M√©todos que debe implementar cualquier reproductor
    void reproducir();
    void pausar();
    void detener();
    void siguienteCancion();
    void cancionAnterior();
    void ajustarVolumen(int volumen);
    boolean estaReproduciendo();
}
```

### ‚ö° Caracter√≠sticas de los M√©todos en Interfaces

```java
public interface EjemploCaracteristicas {
    // ‚ùå INCORRECTO - no puede tener variables de instancia
    // private String nombre;
    
    // ‚úÖ CORRECTO - constantes (public static final impl√≠cito)
    String TIPO_DEFECTO = "Gen√©rico";
    int NUMERO_MAXIMO = 1000;
    
    // ‚úÖ CORRECTO - m√©todos abstractos (public abstract impl√≠cito)
    void metodoAbstracto();
    String obtenerInformacion();
    
    // ‚ùå INCORRECTO - no puede tener constructores
    // public EjemploCaracteristicas() { }
}
```

---

## üîß Implementaci√≥n de una Interfaz - Uso de `implements`

### Sintaxis de Implementaci√≥n

```java
public class NombreClase implements NombreInterfaz {
    // Debe implementar TODOS los m√©todos de la interfaz
    @Override
    public tipoRetorno nombreMetodo(parametros) {
        // Implementaci√≥n espec√≠fica
    }
}
```

### üì± Ejemplo Pr√°ctico: Sistema de Dispositivos

```java
// 1. Declaramos la interfaz
public interface DispositivoElectronico {
    String MARCA_DEFECTO = "Gen√©rica";
    
    void encender();
    void apagar();
    void mostrarEstado();
    int obtenerConsumoEnergia();
}

// 2. Implementamos la interfaz en diferentes clases
public class Telefono implements DispositivoElectronico {
    private boolean encendido;
    private String modelo;
    private int bateria;
    
    public Telefono(String modelo, int bateria) {
        this.modelo = modelo;
        this.bateria = bateria;
        this.encendido = false;
    }
    
    @Override
    public void encender() {
        if (bateria > 0) {
            encendido = true;
            System.out.println("üì± Tel√©fono " + modelo + " encendido");
        } else {
            System.out.println("‚ùå Bater√≠a agotada, no se puede encender");
        }
    }
    
    @Override
    public void apagar() {
        encendido = false;
        System.out.println("üì± Tel√©fono " + modelo + " apagado");
    }
    
    @Override
    public void mostrarEstado() {
        String estado = encendido ? "Encendido" : "Apagado";
        System.out.println("üì± " + modelo + " - Estado: " + estado + " - Bater√≠a: " + bateria + "%");
    }
    
    @Override
    public int obtenerConsumoEnergia() {
        return encendido ? 15 : 2; // Watts
    }
    
    // M√©todo espec√≠fico del tel√©fono
    public void llamar(String numero) {
        if (encendido) {
            System.out.println("üìû Llamando a " + numero);
        } else {
            System.out.println("‚ùå Enciende el tel√©fono primero");
        }
    }
}

public class Laptop implements DispositivoElectronico {
    private boolean encendida;
    private String marca;
    private String procesador;
    
    public Laptop(String marca, String procesador) {
        this.marca = marca;
        this.procesador = procesador;
        this.encendida = false;
    }
    
    @Override
    public void encender() {
        encendida = true;
        System.out.println("üíª Laptop " + marca + " iniciando sistema...");
        System.out.println("üíª Sistema operativo cargado");
    }
    
    @Override
    public void apagar() {
        encendida = false;
        System.out.println("üíª Cerrando aplicaciones...");
        System.out.println("üíª Laptop " + marca + " apagada");
    }
    
    @Override
    public void mostrarEstado() {
        String estado = encendida ? "Encendida" : "Apagada";
        System.out.println("üíª " + marca + " (" + procesador + ") - Estado: " + estado);
    }
    
    @Override
    public int obtenerConsumoEnergia() {
        return encendida ? 65 : 5; // Watts
    }
    
    // M√©todo espec√≠fico de la laptop
    public void ejecutarPrograma(String programa) {
        if (encendida) {
            System.out.println("üíª Ejecutando " + programa);
        } else {
            System.out.println("‚ùå Enciende la laptop primero");
        }
    }
}
```

### üéÆ Ejemplo de Uso

```java
public class PruebaDispositivos {
    public static void main(String[] args) {
        // Crear dispositivos
        Telefono miTelefono = new Telefono("iPhone 15", 85);
        Laptop miLaptop = new Laptop("Dell", "Intel i7");
        
        // Usar como objetos espec√≠ficos
        System.out.println("=== USO ESPEC√çFICO ===");
        miTelefono.encender();
        miTelefono.llamar("123-456-7890");
        
        miLaptop.encender();
        miLaptop.ejecutarPrograma("Visual Studio Code");
        
        // Usar polimorfismo con la interfaz
        System.out.println("\n=== POLIMORFISMO ===");
        DispositivoElectronico[] dispositivos = {miTelefono, miLaptop};
        
        for (DispositivoElectronico dispositivo : dispositivos) {
            dispositivo.mostrarEstado();
            System.out.println("Consumo: " + dispositivo.obtenerConsumoEnergia() + "W");
            System.out.println("Marca por defecto: " + DispositivoElectronico.MARCA_DEFECTO);
            System.out.println("---");
        }
        
        // Apagar todos los dispositivos
        System.out.println("=== APAGANDO DISPOSITIVOS ===");
        for (DispositivoElectronico dispositivo : dispositivos) {
            dispositivo.apagar();
        }
    }
}
```

---

## üîÑ Implementaci√≥n M√∫ltiple

Una de las grandes ventajas de las interfaces es que una clase puede implementar m√∫ltiples interfaces.

### üìö Ejemplo: Sistema de Biblioteca

```java
// Interfaces separadas para diferentes comportamientos
public interface Prestable {
    void prestar(String usuario);
    void devolver();
    boolean estaPrestado();
}

public interface Catalogable {
    String obtenerCodigo();
    String obtenerCategoria();
    void actualizarUbicacion(String nuevaUbicacion);
}

public interface Renovable {
    void renovar();
    boolean puedeRenovarse();
    int diasRestantes();
}

// Clase que implementa m√∫ltiples interfaces
public class Libro implements Prestable, Catalogable, Renovable {
    private String titulo;
    private String autor;
    private String codigo;
    private String categoria;
    private String ubicacion;
    private boolean prestado;
    private String usuarioPrestamo;
    private int diasPrestamo;
    
    public Libro(String titulo, String autor, String codigo, String categoria) {
        this.titulo = titulo;
        this.autor = autor;
        this.codigo = codigo;
        this.categoria = categoria;
        this.ubicacion = "Estanter√≠a Principal";
        this.prestado = false;
        this.diasPrestamo = 0;
    }
    
    // Implementaci√≥n de Prestable
    @Override
    public void prestar(String usuario) {
        if (!prestado) {
            prestado = true;
            usuarioPrestamo = usuario;
            diasPrestamo = 14; // 2 semanas
            System.out.println("üìñ '" + titulo + "' prestado a " + usuario);
        } else {
            System.out.println("‚ùå El libro ya est√° prestado");
        }
    }
    
    @Override
    public void devolver() {
        if (prestado) {
            prestado = false;
            System.out.println("üìñ '" + titulo + "' devuelto por " + usuarioPrestamo);
            usuarioPrestamo = null;
            diasPrestamo = 0;
        } else {
            System.out.println("‚ùå El libro no est√° prestado");
        }
    }
    
    @Override
    public boolean estaPrestado() {
        return prestado;
    }
    
    // Implementaci√≥n de Catalogable
    @Override
    public String obtenerCodigo() {
        return codigo;
    }
    
    @Override
    public String obtenerCategoria() {
        return categoria;
    }
    
    @Override
    public void actualizarUbicacion(String nuevaUbicacion) {
        this.ubicacion = nuevaUbicacion;
        System.out.println("üìç Ubicaci√≥n actualizada: " + nuevaUbicacion);
    }
    
    // Implementaci√≥n de Renovable
    @Override
    public void renovar() {
        if (prestado && puedeRenovarse()) {
            diasPrestamo += 7; // Una semana m√°s
            System.out.println("üîÑ Pr√©stamo renovado. Nuevos d√≠as: " + diasPrestamo);
        } else {
            System.out.println("‚ùå No se puede renovar");
        }
    }
    
    @Override
    public boolean puedeRenovarse() {
        return prestado && diasPrestamo <= 7; // Solo si quedan pocos d√≠as
    }
    
    @Override
    public int diasRestantes() {
        return prestado ? diasPrestamo : 0;
    }
    
    // M√©todo espec√≠fico del libro
    public void mostrarInformacion() {
        System.out.println("üìö " + titulo + " por " + autor);
        System.out.println("   C√≥digo: " + codigo + " | Categor√≠a: " + categoria);
        System.out.println("   Ubicaci√≥n: " + ubicacion);
        if (prestado) {
            System.out.println("   Prestado a: " + usuarioPrestamo + " | D√≠as restantes: " + diasPrestamo);
        } else {
            System.out.println("   Estado: Disponible");
        }
    }
}
```

### üß™ Prueba del Sistema

```java
public class PruebaBiblioteca {
    public static void main(String[] args) {
        Libro libro = new Libro("Cien A√±os de Soledad", "Gabriel Garc√≠a M√°rquez", "LIT001", "Literatura");
        
        // Mostrar informaci√≥n inicial
        libro.mostrarInformacion();
        
        // Probar funcionalidades de Prestable
        System.out.println("\n=== PR√âSTAMO ===");
        libro.prestar("Juan P√©rez");
        libro.mostrarInformacion();
        
        // Probar funcionalidades de Catalogable
        System.out.println("\n=== CATALOGACI√ìN ===");
        System.out.println("C√≥digo: " + libro.obtenerCodigo());
        System.out.println("Categor√≠a: " + libro.obtenerCategoria());
        libro.actualizarUbicacion("Secci√≥n Pr√©stamos");
        
        // Probar funcionalidades de Renovable
        System.out.println("\n=== RENOVACI√ìN ===");
        System.out.println("¬øPuede renovarse? " + libro.puedeRenovarse());
        System.out.println("D√≠as restantes: " + libro.diasRestantes());
        libro.renovar();
        
        // Devolver el libro
        System.out.println("\n=== DEVOLUCI√ìN ===");
        libro.devolver();
        libro.mostrarInformacion();
    }
}
```

---

## üéØ Ventajas de las Interfaces

### 1. **Flexibilidad en el Dise√±o**
```java
// Diferentes implementaciones de la misma interfaz
interface Notificacion {
    void enviar(String mensaje);
}

class NotificacionEmail implements Notificacion {
    public void enviar(String mensaje) {
        System.out.println("üìß Email: " + mensaje);
    }
}

class NotificacionSMS implements Notificacion {
    public void enviar(String mensaje) {
        System.out.println("üì± SMS: " + mensaje);
    }
}

class NotificacionPush implements Notificacion {
    public void enviar(String mensaje) {
        System.out.println("üîî Push: " + mensaje);
    }
}
```

### 2. **Polimorfismo Poderoso**
```java
public class ServicioNotificaciones {
    public void enviarNotificacion(Notificacion notificacion, String mensaje) {
        notificacion.enviar(mensaje); // No importa qu√© tipo espec√≠fico sea
    }
    
    public static void main(String[] args) {
        ServicioNotificaciones servicio = new ServicioNotificaciones();
        
        // Mismo m√©todo, diferentes comportamientos
        servicio.enviarNotificacion(new NotificacionEmail(), "Bienvenido!");
        servicio.enviarNotificacion(new NotificacionSMS(), "C√≥digo: 1234");
        servicio.enviarNotificacion(new NotificacionPush(), "Nueva actualizaci√≥n");
    }
}
```

### 3. **Desacoplamiento de C√≥digo**
```java
// ‚ùå MALO - Acoplado a implementaci√≥n espec√≠fica
class ProcesadorPagos {
    private PayPal paypal = new PayPal();
    
    public void procesar(double monto) {
        paypal.pagar(monto); // Solo funciona con PayPal
    }
}

// ‚úÖ BUENO - Desacoplado usando interfaz
interface ProcesadorPago {
    void procesar(double monto);
}

class ProcesadorPagosFlexible {
    private ProcesadorPago procesador;
    
    public ProcesadorPagosFlexible(ProcesadorPago procesador) {
        this.procesador = procesador;
    }
    
    public void procesar(double monto) {
        procesador.procesar(monto); // Funciona con cualquier implementaci√≥n
    }
}
```

---

## üèãÔ∏è Ejercicios Pr√°cticos

### Ejercicio 1: Sistema de Formas Geom√©tricas
```java
// Crea una interfaz y implementaciones
interface Forma {
    double calcularArea();
    double calcularPerimetro();
    void dibujar();
}

// Implementa para: C√≠rculo, Rect√°ngulo, Tri√°ngulo
```

### Ejercicio 2: Sistema de Empleados
```java
// Crea interfaces para diferentes roles
interface Trabajador {
    void trabajar();
    double calcularSalario();
}

interface Supervisor {
    void supervisar();
    void asignarTarea(String tarea);
}

// Implementa: Desarrollador, Gerente (que es Trabajador y Supervisor)
```

### Ejercicio 3: Sistema de Veh√≠culos
```java
interface Vehiculo {
    void acelerar();
    void frenar();
    int obtenerVelocidadMaxima();
}

interface Volador {
    void despegar();
    void aterrizar();
    int obtenerAltitudMaxima();
}

// Implementa: Carro, Avi√≥n (que es Vehiculo y Volador)
```

---

## ‚úÖ Mejores Pr√°cticas

### 1. **Nombres Descriptivos**
```java
// ‚úÖ BUENO
interface Reproducible {
    void reproducir();
}

// ‚ùå MALO
interface I {
    void r();
}
```

### 2. **Interfaces Cohesivas**
```java
// ‚úÖ BUENO - Una responsabilidad clara
interface Calculadora {
    double sumar(double a, double b);
    double restar(double a, double b);
}

// ‚ùå MALO - M√∫ltiples responsabilidades
interface CalculadoraYBaseDatos {
    double sumar(double a, double b);
    void guardarEnBaseDatos(String datos);
}
```

### 3. **Usar Constantes Apropiadamente**
```java
interface ConfiguracionJuego {
    int VIDAS_INICIALES = 3;
    int PUNTOS_POR_NIVEL = 100;
    String VERSION = "1.0";
    
    void iniciarJuego();
    void terminarJuego();
}
```

---




